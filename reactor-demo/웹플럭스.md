```kotlin
@GetMapping
fun getAll(): Mono<String> {
    val publisher = Mono.zip(
        demoService.find(),
        demoService.find()
    ) { result1, result2 ->
        "$result1, $result2"
    }
```


   
```kotlin
 // --- 여기서부터 WebFlux가 내부적으로 처리하는 부분 ---
    
    // 1. WebFlux가 Subscriber 생성
    val subscriber = object : Subscriber<String> {
        private lateinit var subscription: Subscription
        
        // Publisher와 Subscriber가 연결될 때 호출
        override fun onSubscribe(s: Subscription) {
            subscription = s
            subscription.request(1) // 데이터 1개 요청
        }
        
        // 데이터를 받았을 때 호출
        override fun onNext(data: String) {
            // HTTP 응답 본문에 데이터를 쓰는 작업
            // response.writeWith(data)
        }
        
        // 에러 발생시 호출
        override fun onError(t: Throwable) {
            // HTTP 에러 응답 반환
            // response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR)
        }
        
        // 모든 데이터 처리가 완료되었을 때 호출
        override fun onComplete() {
            // HTTP 응답 완료
            // response.complete()
        }
    }
    
    // 2. Publisher에 Subscriber 연결
    publisher.subscribe(subscriber)
    
    return publisher
}
```


```kotlin
// WebFlux 내부에서는 대략 이런 처리가 일어남
val subscriber = object : Subscriber<String> {
    override fun onNext(data: String) {
        // 1. Content-Type을 application/json으로 설정
        response.headers().contentType(MediaType.APPLICATION_JSON)
        
        // 2. String을 JSON으로 직렬화
        // "Hello, World" -> "\"Hello, World\""
        val jsonData = objectMapper.writeValueAsString(data)
        
        // 3. HTTP 응답 본문에 JSON 데이터 작성
        response.writeWith(jsonData)
    }
}
```


